from pydantic import Field, BaseModel

import bittensor as bt
from typing import List, Dict

class MachineDetails(BaseModel):
    ip: str = ""

class MachineConfig(BaseModel):
    machine_config: Dict[str, MachineDetails] = {
        "Attacker": MachineDetails(),
        "Benign": MachineDetails(),
        "King": MachineDetails(),
    }

class AvailabilitySynapse(bt.Synapse):
    """AvailabilitySynapse is a specialized implementation of the `Synapse` class used to allow miners to let validators know
    about their status/availability to server certain tasks"""

    task_availabilities: dict[str, bool]
    
class PingSynapse(bt.Synapse):
    """
    Synapse for miners to report machine availability and corresponding details.
    """

    ssh_public_key: str = Field(
        title="Validator's SSH Public Key",
        description="A string containing the random ssh public key generated by the miner to give machines access for the validator.",
        allow_mutation=True,
    )

    machine_availabilities: MachineConfig = Field(
        default_factory=dict,
        title="Machine's Availabilities",
        description="A dictionary where keys are machine names and values are MachineDetails instances. Miners populate this field.",
        allow_mutation=True,
    )


    def serialize(self) -> dict:
        """
        Serializes the `PingSynapse` into a dictionary.

        Converts `MachineDetails` instances to dictionaries for external usage.
        """
        return {
            "ssh_public_key": self.ssh_public_key,  # Add this line
            "machine_availabilities": {
                key: details.dict() for key, details in self.machine_availabilities.items()
            }
        }


    @classmethod
    def deserialize(cls, data: dict) -> "PingSynapse":
        """
        Deserializes a dictionary into an `PingSynapse`.

        Converts nested dictionaries into `MachineDetails` instances.
        """
        machine_availabilities = {
            key: MachineDetails(**details)
            for key, details in data.get("machine_availabilities", {}).items()
        }
        
        ssh_public_key = data.get("ssh_public_key", "")  # Retrieve ssh_public_key
        
        return cls(
            ssh_public_key=ssh_public_key,
            machine_availabilities=machine_availabilities
        )

    
class TensorProxSynapse(bt.Synapse):
    """
    TensorProxSynapse is a specialized implementation of the `Synapse`. 
    This class is intended to interact with a streaming response that contains a sequence of tokens,
    which represent prompts or messages in a certain scenario.

    As a developer, when using or extending the `TensorProxSynapse` class, you should be primarily focused on the structure
    and behavior of the prompts you are working with. The class has been designed to seamlessly handle the streaming,
    decoding, and accumulation of tokens that represent these prompts.

    Attributes:

    - `task_name` (str): Name of the task sent to miners. Immutable.
        For now we only process one task type => DDoSDetectionTask

    - `challenges` (List[dict]): These represent the actual input features in the DDoS Detection scenario. Immutable.

    - `prediction` (int): Stores the result of the output label predicted by miners.

    Note: While you can directly use the `TensorProxSynapse` class, it's designed to be extensible. Thus, you can create
    subclasses to further customize behavior for specific scenarios or requirements.
    """

    task_name: str = Field(
        ...,
        title="Task",
        description="The task for the current TensorProxSynapse object.",
        allow_mutation=False,
    )

    challenges: List[dict] = Field(
        ...,
        title="Challenges",
        description="A list of challenges.",
        allow_mutation=False,
    )

    prediction: str = Field(
        "",
        title="Prediction",
        description="Prediction for the output class. This attribute is mutable and can be updated.",
    )



    def deserialize(self) -> str:
        """
        Deserializes the response by returning the prediction attribute.

        Returns:
            str: The prediction result.
        """
        return self.prediction


